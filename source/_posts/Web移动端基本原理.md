---
title: Web移动端基本原理
date: 2017-04-15 22:11:03
catagory: tech
tags: [前端, 移动端, 响应式]
---
这几天看了一些移动端实现布局的方案，做个记录。

# 从PC端讲起
虽然这篇是总结移动端的，但是考虑到像我这种学习前端的萌新都是从PC端开始练起，所以咱们就先来看看在PC端做前端开发是什么个情况。

先来写个页面。
``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
    <h1>Hello World!</h1>
</body>
</html>
```
![HelloWorld页面](/image/2017-04-15 22-52-26屏幕截图.jpg)
什么？这不是HTML入门的第一个页面么？这有什么看头？别急呀，我们现在来看这个页面不是来学写标签的。作为一名合格的前端开发人员，还是要习惯性地问自己一些问题的。比如说对这个页面，h1到底有多宽?

<!--more-->

稍稍分析一下，首先我们知道h1是一个块级元素，那么块级元素是怎么定义的呢？
> 块级元素占据其父元素（容器）的整个空间

这是我们最习惯的一个概念，那h1有多宽的问题就变成了新的问题：h1的父元素——也就是说body,默认情况下有多宽？
> 解决问题的最有效方法是提出最正确的问题

这个问题看起来简单，不就是100%么？但是如果是100%，我们知道百分比是相对大小，那么这个100%是相对于哪个元素来说呢？

废话，当然是浏览器宽度啦，body哪里还会有相对的父元素呢？不，这是因为我们平时在PC开发时，很少关注一个重要的标签，也就是HTML真正的包裹标签——html。

我们做一个实验，在Chrome下F12打开Console，然后给html加一个width:50%，再查看body的宽度，发现body和html具有一样的宽度(这里因为浏览器会自动给body加一个margin,不考虑margin的问题就是一样的宽度)。
![chrome实验查看html标签与body标签间的关系](/image/2017-04-15 22-43-54屏幕截图.jpg)
也就是说，默认情况下，body的宽度是html的100%。那么问题就成了html是多宽呢？这回总该是浏览器的宽度了吧？

没问题，至少，据我所知在**PC端**的情况下没问题。

那么问题是，在移动端就不是这样了么？html的默认宽度不是浏览器的宽度还能是什么？
是什么呢？亲自看一下吧。

## 阶段结论
1. 在PC端下，html默认宽度恒等于浏览器宽度

# 转战移动端
我这里的意思不是说把上面的网页放到手机上运行，不然每次修改页面都要用真机测试一次，早就没人想开发前端了。

还是上面那个网页，我们继续用Chrome Console里自带的模拟手机的功能（Win键盘快捷键Ctrl+Shift+M）
![chrome模拟手机页面](/image/2017-04-16 14-25-08屏幕截图.png)
我们可以在模拟界面最上面看到我现在模拟的是iphone5的手机(啊，还是很希望有一部真机测试2333)，它的屏幕大小是320x568px，后面的100%指的是在浏览器里显示的大小，就是它在真实世界里大小的100%。

然后按照PC端的思路，html是浏览器的大小在这里宽度应该是320px，我们看一下它的实际计算宽度
![移动端html宽度计算](/image/2017-04-15 23-01-28屏幕截图.jpg)
嗯？WTF？发生了什么，好像和想象中的不太一样……我们看到在320px宽度的设备上，html标签的宽度计算结果是980px？这难道只是Chrome移动端计算元素宽度时的BUG？

嗯，让我们修改一下html的代码，我想你应该知道在PC端如果想让一个元素隐藏除了用display:none或者visibility:hidden（额，虽然这两方法差别还是很大的……）还可以把它移动到可见范围之外，比如说left:100000px（当然……没人会蠢到写这种东西吧，这里只是为了实验。left:100%一般就足够解决各种问题了），我们希望在320px宽度的手机上也实现类似的效果。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
    <h1>Hello World!</h1>
    <p style="position: absolute; left: 600px">I shouldn't be seen under the smartphone whose device-width is lower than 600px</p>
</body>
</html>
```
然后假设你忘了亲自看一眼就自信的把它提交给了测试……不出1分钟，你就会获得一个BUG反馈
![这是个什么鬼？怎么能让用户看到这种东西？！](/image/2017-04-15 23-17-29屏幕截图.jpg)
这是什么鬼？怎么能让用户看到这种东西？！
> 写前端在时间允许的情况下，请务必多调试多调试多调试，在100种设备上调试都不为过

很好，现在你应该理解了，html默认的宽度在移动端的奇怪现象了吧。
但是如果这个现象真的奇怪到不合理，那么全世界的程序员不会这么长时间都坐视不理的。

那么新的问题是：为什么默认情况下要在一个320px宽的设备上把html宽度设定成这样呢？

## 阶段结论
1. 在移动端下，html宽度不一定等于浏览器宽度

# 移动端设备厂商 & 移动端浏览器厂商：我们希望给用户尽可能好的视觉体验
现在暂时回到几年前，那时候以IPhone和Android为代表的新兴智能机还没能出现在市场的时候，没有多少人能想到，现在的我们可以抱着装在口袋里的东西浏览各种高端酷炫的网页（能把html加载出来再把基本的CSS支持一下就已经很了不起了）。所以说当然也没有人闲的无聊会想着去开发一些能够在320px宽度下正常显示的页面。

所以当智能机出现的时候，设备厂商和浏览器厂商费尽心思要做的第一件事儿就是，想办法让PC上那些超过1000px宽度的网页，正确且正常的在320px宽的设备上显示。WOW！想想这确实很麻烦，不过最基本的想法就是映射了。

我们都知道，在访问网页时，页面是由浏览器进行渲染的。比如在PC上渲染时就会有类似下面的“对话”
>HTML页面妹子：浏览器大叔，我要请你帮我绘制一下，请问你能给我的最大的绘制空间是多少呀？<br/>
  浏览器大叔：哦，好的，我查一下，我现在有1080px的宽度可以让你绘制 <br/>
  HTML页面妹子：嗯嗯，我知道了，谢谢大叔。（把1080作为html标签的宽度）

那么到了移动端呢？大概是这样：
>HTML页面妹子：浏览器大叔，我要请你帮我绘制一下，请问你能给我的最大的绘制空间是多少呀？<br/>
  浏览器大叔：哦，好的，我查一下……（……怎么只有320px，不够妹子用啊！好在爹爹以前教导我，遇到这种情况，就告诉妹子有980px，我来进行映射就好了）……哦，我现在有980px的宽度可以给你绘制<br/>
  HTML页面妹子：嗯嗯，我知道了，谢谢大叔。（把980作为html标签的宽度）<br/>
  （之后HTML妹子在绘制的时候，浏览器大叔都会把HTML妹子绘制的像素映射到设备实际的像素）

那么现在事情就变得有意思了，比如说，CSS设置的一个width:100px的button，默认情况下在宽度为320px宽的设备下到底是多少像素呢？

哈，这个数学题还是难不倒我们的。如果按照html是980px考虑的话（不是所有情况下移动端html默认都是980px，这个值一般在768px ~ 1024px之间，和浏览器厂商设备厂商有关），那么实际像素x / 320 = 100 / 980, x = 33px。要记住，再精密的设备也渲染不出半个像素
其实这个按钮到底是33px还是10000px意义并不大（不过你要是写了一个10000px的按钮，估计设计师会追着打你……）,这里最重要的东西是我们知道了，*写在代码里的像素并不一定是最终展示在设备上的像素*。

现在情况看起来有点复杂了，不过问题还没完……

## 阶段结论
1. 移动端浏览器默认会对页面进行映射
2. 写在代码里的像素并不一定是最终展示在设备上的像素

# 天呀，这个网页上的字实在是太小了
根据上面的计算，对于正常情况下一个16px的汉字（它在PC端显示很正常），放到移动端占据的真实像素就是5px。
![优雅的PC端](/image/2017-04-16 15-15-10屏幕截图.png)
![你能看见这个页面到底说了什么么？](/image/2017-04-16 15-16-24屏幕截图.png)
下面的这个显示的效果，就是真实的效果，不信的话可以拿真机试试。别说是汉字了，就连标题读起来都心累。

我们要理解，之所以移动端显示PC的页面要缩放，是*让用户能完整的知道页面各个位置的布局和功能*。

但是至于看清了布局能不能看清文字……浏览器还真解决不了这个问题，所以用户就会双击触屏或者进行手势操作，对他感兴趣的部分进行放大（当然之后很可能还会缩小回原来的样子）……

嗯……等等……放大……放大……放大？

我们对比一下在PC端的经验，有些时候我们在浏览网页的时候偶尔也会调节浏览器的大小。那么这个是不是原理和手机端的缩放原理一样呢？

我们知道在PC上，如果用百分比定义元素宽度的话（比如块级元素默认就是相对父元素的100%），当浏览器大小改变时，元素占据的像素数也会改变。如果不理解原因可以按照以下思路推理（仅在PC端有效）：
1. 百分比定义的元素宽度是根据其父节点宽度的像素值计算而来的
2. 当父节点宽度改变的时候子节点会重新计算宽度像素值
3. html的宽度默认恒等于浏览器宽度
4. 浏览器宽度改变时，html宽度改变，body被重新计算，body下所有百分比定义的子元素均重新计算。

> Talk is cheap, show me the code

我们来实际看看浏览器大小改变时的效果。

首先把上面的代码改一下。我们来准备一个占body100%大小的ul，为了能观察到变化情况，在下面添加10个li，内容对应0-9，每个宽度占据ul的10%。

哦我忘了li是块级元素，不过没关系，我们把它改成行内块级（display:inline-block）元素，这样就可以在行内显示的情况下修改宽度。（行内非替换元素修改width属性无效）

(ps:如果你不知道行内非替换元素为什么修改width无效，请看：)
1. [what is a non-replaced inline element?](http://stackoverflow.com/questions/12468176/what-is-a-non-replaced-inline-element)
2. [Inline elements and padding](http://maxdesign.com.au/articles/inline/)
3. [Visual formatting model details](https://www.w3.org/TR/REC-CSS2/visudet.html#Computing_widths_and_margins)

另外，在设置inline-block的时候需要特别注意标签间的空格……回车换行也不行，否则空格回车都会被浏览器当做内部节点（占据1em的大小）渲染出来。

最后，为了让每个元素占据的空间更明显，我们给它设置一个1px的border。但这会导致li的盒模型在content-area.width = 10% * ul.width的基础上，多出了左右两边的border共2px
那么10个li合起来就占据了(10% * ul.width + 2) * 10的宽度，很明显超出父元素20px，就会出现换行。

这时候我们可以设置box-sizing:border-box;意思就是width:10%这个宽度包含了content,padding,border的全部内容
    参见[CSS3 box-sizing 属性](http://www.w3school.com.cn/cssref/pr_box-sizing.asp)
然后我们的样式有点多了，最好把它们都提出来。

下面是修改后的代码
``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
       .p_should_hide{
            position: absolute;
            left: 600px;
       }
       .100button{
            width: 100px;
       }
       .16font_size{
            font-size: 16px;
       }
       ul{
            width: 100%;
            padding: 0;
            margin: 0;
       }
       ul li{
            display: inline-block;
            width: 10%;
            box-sizing: border-box;
            border: 1px solid #000;
       }
    </style>
</head>
<body>
    <h1>Hello World!</h1>
    <p class="p_should_hide">I shouldn't be seen under the mobile browser</p>
    <button class="100button">我是100px宽的按钮</button>
    <p class="16font_size">设计师给我的设计方案是16px,看起来在PC上很优雅</p>
    <ul>
        <li>0</li><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li>
    </ul>
</body>
</html>
```
我们可以看到窗口放小的过程中，html一直等于窗口的宽度，并且ul,li的宽度一直被重新计算
![在PC下将窗口调到最小_原理](/image/2017-04-16 15-29-32屏幕截图.png)
好啦，到这里已经足够说清PC端页面大小改变的机制了。重点就在于PC端html的宽度恒等于浏览器的宽度。

让我们回到移动端，html的宽度……额……和浏览器的宽度……不一定相等啊。而且在缩放过程中，移动端浏览器的宽度也根本不会变啊。

所以结论很明显，移动端的缩放机制和PC端浏览器窗口大小改变的原理绝对不一样。

那么新的问题又来了，移动端缩放的过程中到底发生了什么？

## 阶段结论
1. 移动端的缩放机制和PC端浏览器窗口大小改变的原理不一样

# PC上的缩放
移动端缩放这个问题，还是有点复杂。

我们先不管移动端，只考虑缩放的问题。

不知道你有没有注意过，其实现代的PC浏览器上一般都会有缩放的功能，这是为了满足一些视力不太好的用户（当然有时候也能帮助一些设计尺寸很反人类的网页）

在Chrome下Ctrl+"+"/"-",或者Ctrl+鼠标滑轮滚动就能实现页面的缩放。

我们对上面的页面进行175%的缩放
![PC端175%缩放效果](/image/2017-04-16 15-31-43屏幕截图.png)
首先要说明一点，这张图并不是图片放大的结果，它实际就是这样。你可以在自己的电脑上尝试。

哈，这下可就麻烦了，我们在上面讨论中的第一个结论就是*html默认宽度恒等于浏览器宽度*，但是这里明显出了问题，我现在的浏览器宽度是1366px，但是html的计算宽度却只有780.57px。看来我们需要修改一下最初的结论
> 在PC端不进行缩放的情况下，html默认宽度恒等于浏览器宽度

这个结论看起来比之前的那个更复杂了，但是其实这并不会造成太大的问题。因为在布局合理的情况下，有多少PC端用户会开着缩放浏览你的页面呢？

在这里真正有启发性的是缩放的本质，我们计算一下，1366 / 780.57，我的计算器显示为1.750003203，也就是我们的缩放比例。

现在我们可以来梳理一下PC端缩放的过程了：
1. 用户通过缩放工具选择了某个缩放比例
2. 计算缩放后html元素尺寸 = 浏览器尺寸 / 缩放比例
3. 计算html后代元素的尺寸
4. 将html完整的映射到浏览器的大小

嗯？映射？这个词怎么有点耳熟呢？等等，我们是不是说过移动端默认会对页面进行映射？
没错，没错。是这样，这里的两种映射的概念没有一点区别。

如果你学过一些图像处理的知识，你应该知道要把一张2*2像素的图片映射到4*4像素的设备上，最简单的方法只需要把原始图片每1个像素(1*1格)，复制到设备中的4个像素(2*2格)上就可以了。缩小的原理和这个一样。

所以缩放本质上讲就是一种原始像素=>设备像素的映射关系。

好啦，到现在为止我们终于找到了一点点PC和移动端的共通之处，我们在这里整理一下html默认情况下在移动端呈现的过程
1. 浏览器给html一个指定宽度，该宽度由设备厂商&浏览器厂商决定，一般为768px~1024px之间，980px比较常见
2. 浏览器建立一个html到设备宽度之间的映射，我们可以把它叫做*初始缩放*

## 阶段结论
1. 在PC端不进行缩放的情况下，html默认宽度恒等于浏览器宽度
2. PC端缩放时，计算缩放后html元素尺寸 = 浏览器尺寸 / 缩放比例
3. 所以缩放本质上讲就是一种原始像素=>设备像素的映射关系。
4. 移动端显示页面时，有一个初始缩放

# 移动端的用户缩放
好啦，理解了缩放，再来看移动端缩放。

还是拿上面的页面，我们利用Chrome模拟器在移动端进行放大测试（在Chrome模拟器调试时，双击页面进行放大）
![Chrome模拟器中进行调试用户缩放](/image/2017-04-16 12-36-30屏幕截图.png)
唔，这个显示的效果太小了，但我不想让它更大，那样需要再加一些CSS属性，然后说不定会导致更麻烦的属性计算问题。

但亲自看一遍放大过程或者数格子就能看出来，在移动端放大后只显示了8.5个格子，查看html的宽度，它还是980px。
![Chrome模拟器中进行调试用户缩放_html宽度](/image/2017-04-16 13-42-18屏幕截图.png)
唔……这就麻烦了，同样是用户缩放，PC端改变了html的宽度而移动端却没有这么做……但仔细考虑一下这样是合理的，理由就是移动端的浏览器宽度通常很窄。

移动端的浏览器宽度通常很窄，如果你放大了html的宽度，让html依旧占满浏览器，那么下面的块级元素以及其它需要根据父级标签进行计算的元素都会被放大，而且它们中的大部分还都会被限制在html容器内部也就是都会显示在屏幕上……想象一下，那简直就是一锅粥。(tip:如果你想象不到那会有多造，把你的浏览器尺寸拉到最小，然后使用缩放工具试一下你就知道了……)

我们现在解决原始的问题移动端用户缩放时发生了什么：
1. 用户通过手势（扩大手势，缩小手势或者双击）进行比例为x的缩放
2. 根据用户缩放比例计算新的映射关系

我们还是看那个CSS中定义为100px的button，移动端尺寸宽320px，浏览器给html的宽度为980px，根据前面的计算，这个按钮在设备上占据了33px。

现在用户进行了一个放大2倍的手势操作。
> 初始映射关系：980px => 320px
  放大2倍后，你能在设备上看见的html的宽度为：980px / 2 = 490px
  放大2倍后的映射关系：490px => 320px

现在再来计算button显示的宽度x: x / 320 = 100 / 490, 得x = 65px。注意65 != 33 * 2的原因是不存在小数点的像素。

太棒了，现在我们可以精确知道用户缩放以后的像素了。可是先别急，因为只是知道这个像素……其实……基本上可以说没有任何意义。

## 阶段结论
1. 移动端用户缩放时不会改变html的宽度（这种缩放基本类似缩放一张图片），只会修改原像素=>实际像素的映射关系。“初始缩放”除外，但它只在移动端加载页面时发生一次并且修改html宽度(为了区别我宁愿把初始缩放叫做初始映射，但没办法，标签就是这么定义的orz)

# 北京到杭州的距离是……1568……px?
作为前端开发人员，我们和设计师交流的必背单词之一就是px。这个按钮100px，这个div要左移1px。而且经过上面的讨论，我们也知道了，*在CSS中写好的像素并不是最后呈现出的实际像素*。

不过我还是有个问题，就是到底多大的按钮，才能保证用户能容易的用手指点中？

略微思考后，你可能想回答某一个实际的像素值，但这个像素值有实际意义么？
其实换个角度想，这个问题正确的问法应该是，用户的手指一般有多粗？结果你告诉我一个像素值……
这就好比我问你北京到杭州有多远，你思考了一阵告诉我……1568……px。

很明显现在我们又引出了新的问题，就是1px，在现实世界里，到底有多长？老师在学校没有教过你这类单位转换，当然也不可能在某某标准单位定义里找到相关的东西。也就是说，1px的实际长度完全可以是任意的！

好吧，我们好不容易解决了缩放的问题，确定了实际显示的像素大小，但现在却发现这个大小完全没有意义，它可能代表1cm,1m甚至1km……

怎么办呢？我们完全可以要求全世界的人，规定一个统一的换算单位，比如1px=1cm。但这明显不合理，比如说你想要显示一张1080*763的图片，你就必须购买一个1080*763cm的设备……要不然全世界只有少的可怜的几种固定大小的图片，要不然你就得为了看图片买齐各种大小的设备。

如果你以前做过任何和图像有关的事情，或者你在学计算机的时候学习过显示器的知识，你就应该知道有一个叫[图像分辨率](https://zh.wikipedia.org/wiki/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0)的概念（为了把它和显示分辨率区别，一般都叫它像素密度……但我觉得分辨率的率本来就该含有密度的意思），它代表了每个单位长度中包含的像素数，但遗憾的是，它的单位长度用的是英寸……作为中国人，我对英寸这个概念实在是没什么亲切感，为了便于后面的理解，请允许我在这篇文章里讨论细节的时候把单位长度换成cm（其实无所谓啦，只是个长度而已）。

我们这里就假设有一个宽10cm，高20cm的设备，它的像素密度是32px/cm，所以说它的像素为320*640，我们就叫它设备A吧。
还有一个同样宽10cm，高20cm的设备，它的像素密度是64px/cm，像素就是640*1280，我们叫它设备B。

我们来看看那个CSS定义的100px的button在这两个设备上会怎么被映射？

> A设备：
> 经过设备厂家&浏览器厂家设定的默认初始缩放：html.width = 980px
> 实际像素： x / 320 = 100 / 980 => x = 33px
> 实际长度： l = 33 / 32 = 1cm

> B设备：
> 经过设备厂家&浏览器厂家设定的默认初始缩放：html.width = 980px
> 实际像素： x / 640 = 100 / 980 => x = 65px
> 实际长度： l = 65 / 64 = 1cm

WOW！我们发现只要设备厂家和浏览器厂家给出了结果相同的初始缩放，那么按照映射关系，即便button实际占据的像素数不同，但最后的实际长度基本上是相等的。

但是实际像素的不同会有什么影响呢？比如说我们的button用了一个从左向右的渐变色，再假设渐变方向上的每个元素都有一个新的颜色值。那么对于设备A，就有33种颜色，而设备B有65种颜色。所以这就是高分辨率的意义。

最后我们整理一下在没有用户缩放影响下的实际长度计算公式
> CSS_px => CSS中定义的像素
> device_px => 设备的像素数
> html_px => 经过初始缩放后的html像素数
> PPI => 设备像素密度
> device_length => 设备实际长度
> 经过设备厂家&浏览器厂家设定的默认初始缩放： html_px
> 实际像素： device_px × CSS_px / html_px
> 实际长度： (device_px × CSS_px) / (PPI × html_px) = device_length × CSS_px / html_px

好，现在我们把这篇文章里的两个主要话题结合起来讨论一个主题作为结尾：
1. 移动端的缩放
2. 移动端的像素密度

我们要讨论的是，如何充分利用高分辨率屏幕的分辨率。首先我们假设A和B的设备厂家&浏览器厂家出于某些原因（下一篇我们会讨论这些原因），慎重选择了默认初始缩放的值，然后使缩放后的html.width = 320px

然后我这里有一张宽320px的图像，我希望让它显示在页面最上面并且充满浏览器的宽度，PC下我们当然知道该怎么办。现在我们只考虑在设备A，设备B下的情况。

根据之前学会的计算方法，我们很容易得到：
> A设备：
> 经过设备厂家&浏览器厂家设定的默认初始缩放：html.width = 320px
> 实际像素： x / 320 = 320 / 320 => x = 320px
> 实际长度： l = 320 / 32 = 10cm

> B设备：
> 经过设备厂家&浏览器厂家设定的默认初始缩放：html.width = 320px
> 实际像素： x / 640 = 320 / 320 => x = 640px
> 实际长度： l = 640 / 64 = 10cm

看起来似乎没什么问题。但是……

我们可以看到，本来只有320px的图片，在设备B上却占据640px的像素数。换句话说，用户花钱买了高分辨率的设备，就是希望能有更好的用户体验，但是这里却给了他们和设备A相同的结果……
> 用户利益至上

站在你的用户的角度考虑，这肯定不合理。那么我们可以为B设备的用户提供更清晰的图片嘛？比如说宽640px的图片。
> B设备：
> 经过设备厂家&浏览器厂家设定的默认初始缩放：html.width = 320px
> 实际像素： x / 640 = 640 / 320 => x = 1280px
> 实际长度： l = 1280 / 64 = 20cm

Oh!太糟糕了，这样子的话设备A，B结果就不一致了。

怎么办呢？可不可以利用用户缩放把图片缩放0.5倍？当然不行……你可以算一下，因为html.width没有改变，所以页面内所有元素宽度都不变，然而你把映射关系改成了原像素的0.5倍，那么整个页面的所有元素都会被缩小0.5被，那么A，B设备之间还是不一致。

所以这里的正确问题是能不能修改html.width的值，再进一步就是说，能不能修改“初始缩放”，得到不同的html.width的值？

好吧，关于这个的答案当然可以，但是具体的内容就放到下一篇讲吧。

## 阶段结论
1. 显示在设备上的实际像素并不代表用户最终见到的尺寸
2. 影响最终用户见到的尺寸的因素：设备长度，CSS定义的像素数，经过初始缩放后的html像素数

# 总结结论
1. 在PC端用户未缩放的情况下，html默认宽度恒等于浏览器宽度
2. 在移动端下，html宽度不一定等于浏览器宽度
3. 移动端浏览器默认会对页面进行映射——“初始缩放”
4. 写在代码里的像素并不一定是最终展示在设备上的像素
5. 移动端的缩放机制和PC端浏览器窗口大小改变的原理不一样
6. PC端缩放时，计算缩放后html元素尺寸 = 浏览器尺寸 / 缩放比例
7. 缩放本质上讲就是一种原始像素=>设备像素的映射关系。
8. 移动端显示页面时，有一个初始缩放
9. 移动端用户缩放时不会改变html的宽度，只会修改原像素=>实际像素的映射关系。“初始缩放”除外，但它只在移动端加载页面时发生一次并且修改html宽度
10. 显示在设备上的实际像素并不代表用户最终见到的尺寸
11. 影响最终用户见到的尺寸的因素：设备长度，CSS定义的像素数，经过初始缩放后的html像素数

# 待解决的问题
讲了这么多，也许你会发现很多地方都有一个核心问题……就是在移动端怎么找到这个初始缩放，以及是否能修改它。这就涉及到了移动端适配的核心问题——Viewport

